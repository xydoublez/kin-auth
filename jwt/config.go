package jwt

import (
	"context"
	"crypto/hmac"
	"encoding/base64"
	"encoding/json"
	"strings"
	"time"
)

// MaxPayloadLength is the maximum payload length we support.
// The purpose is to prevent tokens don't fit into URLs or HTTP headers.
var MaxPayloadLength = 4000

type Config struct {
	algorithms          []*Algorithm
	secret              []byte
	CheckNotRevokedFunc func(c context.Context, data []byte) error
}

func NewConfig(secret string, algorithms ...*Algorithm) *Config {
	if len(algorithms) == 0 {
		algorithms = DefaulAlgorithms
	}
	return &Config{
		algorithms: algorithms,
		secret:     []byte(secret),
	}
}

func CheckNotExpired(data []byte) error {
	token := &struct {
		ExpiresAt time.Time `json:"exp,omitempty"`
	}{}
	err := json.Unmarshal(data, token)
	if err != nil {
		return ErrMissingExpiration
	}
	if time.Now().Before(token.ExpiresAt) {
		return nil
	}
	return ErrExpired
}

func (config *Config) CheckNotRevoked(c context.Context, data []byte) error {
	f := config.CheckNotRevoked
	if f == nil {
		return nil
	}
	return f(c, data)
}

var base64Encoding = base64.URLEncoding.WithPadding(base64.NoPadding)

// EncodeToString encodes JWT token.
func (config *Config) EncodeToString(c context.Context, payload []byte) string {
	if len(payload) > MaxPayloadLength {
		panic(ErrTooLarge)
	}
	algorithm := config.algorithms[0]

	// STEP 1: HEADER
	buffer := make([]byte, 0, 128+len(payload))
	buffer = append(buffer, algorithm.header...)

	// STEP 2: PAYLOAD
	buffer = append(buffer, '.')
	buffer = append(buffer, base64Encoding.EncodeToString(payload)...)

	// STEP 3: SIGNATURE
	hash := algorithm.hashFunc(config.secret)
	hash.Write(buffer)
	signatureBase64 := base64Encoding.EncodeToString(hash.Sum(nil))
	buffer = append(buffer, '.')
	buffer = append(buffer, signatureBase64...)
	return string(buffer)
}

// DecodeString decodes JWT token, validates the signature, and returns the payload.
func (config *Config) DecodeString(c context.Context, value string) ([]byte, error) {
	// STEP 1: FIND ALGORITHM
	//
	// Find first dot
	firstDot := strings.IndexByte(value, '.')
	if firstDot < 0 {
		return nil, ErrParsing
	}

	// Extract header and find algorithm that matches it
	algorithm, err := config.findAlgorithm(c, value[:firstDot])
	if err != nil {
		return nil, err
	}

	// STEP 2: DECODE SIGNATURE
	//
	// Find last dot
	lastDot := strings.LastIndexByte(value, '.')
	if lastDot < 2 {
		return nil, ErrParsing
	}
	// Extract signature and decode base64
	signature, err := base64Encoding.DecodeString(value[lastDot+1:])
	if err != nil {
		return nil, ErrSignatureParsing
	}

	// STEP 3: CALCULATE CORRECT SIGNATURE
	hf := algorithm.hashFunc(config.secret)
	hf.Write([]byte(value[:lastDot]))
	expectedSignature := hf.Sum(nil)

	// STEP 4: CHECK THAT SIGNATURES ARE EQUAL
	if hmac.Equal(signature, expectedSignature) == false {
		return nil, ErrSignatureValue
	}

	// STEP 4: DECODE PAYLOAD
	payloadBase64 := value[firstDot+1 : lastDot]
	payloadBytes, err := base64Encoding.DecodeString(payloadBase64)
	if err != nil {
		return nil, ErrParsing
	}
	return payloadBytes, nil
}

func (config *Config) findAlgorithm(c context.Context, header string) (*Algorithm, error) {
	// Fast method of finding algorithm:
	// Assume that the token was generated by this configuration.
	// Compare strings.
	for _, algorithm := range config.algorithms {
		if header == algorithm.header {
			return algorithm, nil
		}
	}

	// Fast method didn't work
	// Decode base64
	data, err := base64Encoding.DecodeString(header)
	if err != nil {
		return nil, ErrHeaderParsing
	}

	// Unmarshal JSON object
	var jsonObject struct {
		Type    string `json:"typ"`
		AlgName string `json:"alg"`
	}
	err = json.Unmarshal(data, &jsonObject)
	if err != nil {
		return nil, ErrHeaderParsing
	}

	// Check that type is correct
	if jsonObject.Type != "JWT" {
		return nil, ErrHeaderType
	}

	// Find algorithm
	algName := jsonObject.AlgName
	for _, algorithm := range config.algorithms {
		if algName == algorithm.name {
			return algorithm, nil
		}
	}
	return nil, ErrHeaderAlgorithm
}
